import { AuthEvent } from "../../types/index.js";
import { CivicAuthError, CivicAuthErrorCode } from "../types/AuthTypes.js";
import { PopupError } from "../../../services/types.js";
import { createLogger as createLoggerFn } from "../../utils/logger.js";
export class PopupHandler {
    config;
    logger = createLoggerFn("popup"); // Create own logger
    popup;
    popupCheckInterval;
    onAuthSuccess;
    onAuthError;
    cleanup;
    constructor(handlerConfig) {
        this.config = handlerConfig.config;
        // Don't use handlerConfig.logger - use our own logger instead
        this.onAuthSuccess = handlerConfig.onAuthSuccess;
        this.onAuthError = handlerConfig.onAuthError;
        this.cleanup = handlerConfig.cleanup;
    }
    /**
     * Initiates authentication flow using a popup window.
     *
     * Opens a new browser window/tab for authentication, handles browser compatibility
     * (especially Safari), and sets up monitoring for the authentication process.
     *
     * @param fullAuthUrl - The complete authentication URL to open in the popup
     * @throws {PopupError} When popup window cannot be opened (blocked by browser)
     * @returns Promise that resolves when popup setup is complete
     */
    async handleNewTabAuth(fullAuthUrl) {
        this.logger.info("üöÄ Starting new tab authentication", {
            url: fullAuthUrl,
            userAgent: navigator.userAgent,
            isSafari: /Safari/.test(navigator.userAgent) &&
                !/Chrome/.test(navigator.userAgent),
        });
        try {
            // For Safari, use specific window features that work better
            const isSafari = /Safari/.test(navigator.userAgent) &&
                !/Chrome/.test(navigator.userAgent);
            const windowFeatures = isSafari
                ? "width=500,height=600,scrollbars=yes,resizable=yes"
                : "";
            const popupWindow = isSafari
                ? window.open(fullAuthUrl, "_blank", windowFeatures)
                : window.open(fullAuthUrl, "_blank");
            this.logger.info("üì± Popup window attempt result", {
                popupWindow: popupWindow,
                popupWindowType: typeof popupWindow,
                isNull: popupWindow === null,
                isUndefined: popupWindow === undefined,
                windowFeatures: isSafari ? windowFeatures : "none specified",
                isSafari,
            });
            if (!popupWindow) {
                throw new PopupError("Failed to open popup window - likely blocked by browser");
            }
            // Additional Safari-specific check: Safari might return a window object but still block it
            if (isSafari) {
                // Give Safari a moment to potentially close the popup if it was blocked
                setTimeout(() => {
                    if (popupWindow.closed) {
                        this.logger.warn("üö´ Safari popup was immediately closed (likely blocked)");
                        const error = new PopupError("Safari blocked popup window");
                        if (this.config.events) {
                            this.config.events.emit(AuthEvent.SIGN_IN_ERROR, {
                                detail: error.message,
                                error,
                            });
                        }
                        this.onAuthError(error);
                        return;
                    }
                }, 100);
            }
            this.logger.info("‚úÖ Popup window opened successfully", {
                popupWindow: !!popupWindow,
                popupClosed: popupWindow.closed,
                popupLocation: this.getPopupLocationSafely(popupWindow),
            });
            // Set up popup monitoring
            this.monitorPopup(popupWindow);
        }
        catch (error) {
            this.logger.error("‚ùå Popup window creation failed", {
                error: error,
                errorType: error instanceof PopupError ? "PopupError" : "Other",
            });
            if (error instanceof PopupError) {
                // Re-throw PopupError to be caught by the main authentication flow
                throw error;
            }
            else {
                // Wrap other errors as PopupError
                throw new PopupError(`window.open has thrown: ${error instanceof Error ? error.message : String(error)}`);
            }
        }
    }
    /**
     * Safely retrieves the current location of a popup window.
     *
     * Attempts to access the popup's location.href property, handling cross-origin
     * access restrictions gracefully by returning a descriptive message instead of throwing.
     *
     * @param popup - The popup window to get location from
     * @returns The popup's URL or a descriptive message if access is restricted
     */
    getPopupLocationSafely(popup) {
        try {
            return popup.location.href;
        }
        catch {
            return "cross-origin (cannot access)";
        }
    }
    /**
     * Monitors a popup window for authentication results and handles communication.
     *
     * This method sets up a postMessage listener to receive authentication results from the popup
     * and periodically checks if the popup has been closed. It handles success/error messages
     * and automatically cleans up resources when the popup closes or times out.
     *
     * @param popup - The popup window to monitor for authentication completion
     *
     * @remarks
     * - Monitors popup for up to 5 minutes (300 checks at 1-second intervals)
     * - Listens for 'auth_success' and 'auth_error' message types from the popup
     * - Automatically removes event listeners and resolves/rejects promises when done
     * - Logs detailed debugging information throughout the monitoring process
     *
     * @private
     */
    monitorPopup(popup) {
        this.logger.info("üëÄ Starting popup monitoring");
        let checkCount = 0;
        const maxChecks = 300; // 5 minutes at 1 second intervals
        let popupMessageHandler = null;
        // Set up postMessage listener for popup communication
        popupMessageHandler = (event) => {
            this.logger.debug("üì® Received message from popup", {
                origin: event.origin,
                data: event.data,
                source: event.source === popup,
                messageType: event.data?.type,
                isFromTargetPopup: event.source === popup,
            });
            // Verify the message is from our popup
            if (event.source !== popup) {
                this.logger.debug("üö´ Ignoring message from different source", {
                    expectedSource: popup,
                    actualSource: event.source,
                });
                return;
            }
            const message = event.data;
            if (message && typeof message === "object" && message.type) {
                this.logger.info("‚úÖ Valid popup message received", {
                    type: message.type,
                    detail: message.detail,
                    hasData: !!message.data,
                });
                switch (message.type) {
                    case "auth_success":
                        this.handlePopupSuccess(message, popupMessageHandler);
                        break;
                    case "auth_error":
                        this.handlePopupError(message, popupMessageHandler);
                        break;
                    default:
                        this.logger.debug("ü§∑ Unknown message type from popup", {
                            type: message.type,
                            fullMessage: message,
                        });
                }
            }
            else {
                this.logger.debug("üì® Non-auth message received from popup", {
                    messageType: typeof message,
                    message,
                });
            }
        };
        // Add the message listener
        window.addEventListener("message", popupMessageHandler);
        this.logger.info("üì° Added popup message listener", {
            popupWindowExists: !!popup,
            popupClosed: popup.closed,
        });
        const checkClosed = () => {
            checkCount++;
            this.logger.debug(`üîç Popup check #${checkCount}`, {
                closed: popup.closed,
                location: this.getPopupLocationSafely(popup),
                maxChecks,
            });
            if (popup.closed) {
                this.handlePopupClosed(popupMessageHandler);
                return;
            }
            if (checkCount >= maxChecks) {
                this.handlePopupTimeout(popupMessageHandler);
                return;
            }
            // Check popup location for redirect (this is now mainly for debugging)
            this.checkPopupLocation(popup);
            // Continue monitoring
            setTimeout(checkClosed, 1000);
        };
        // Start monitoring
        setTimeout(checkClosed, 1000);
    }
    /**
     * Handles successful authentication completion from the popup.
     *
     * Processes the authentication success message received from the popup window,
     * emits success events, triggers the success callback, and performs cleanup.
     *
     * @param message - The authentication message containing success data
     * @param popupMessageHandler - The message event handler to clean up, or null if none exists
     */
    handlePopupSuccess(message, popupMessageHandler) {
        this.logger.info("üéâ Popup authentication successful");
        this.config.events?.emit(AuthEvent.SIGN_IN_COMPLETE, {
            detail: "Popup authentication successful",
            data: message.data,
        });
        this.onAuthSuccess(message.data || {});
        this.cleanup();
        // Clean up message listener
        if (popupMessageHandler) {
            window.removeEventListener("message", popupMessageHandler);
        }
    }
    /**
     * Handles authentication errors received from the popup.
     *
     * Processes error messages from the popup window, emits error events,
     * creates appropriate CivicAuthError instances, and performs cleanup.
     *
     * @param message - The authentication message containing error details
     * @param popupMessageHandler - The message event handler to clean up, or null if none exists
     */
    handlePopupError(message, popupMessageHandler) {
        this.logger.error("‚ùå Popup authentication failed", {
            detail: message.detail,
        });
        this.config.events?.emit(AuthEvent.SIGN_IN_ERROR, {
            detail: message.detail || "Popup authentication failed",
            error: message.error,
        });
        const error = new CivicAuthError(message.detail || "Popup authentication failed", CivicAuthErrorCode.INVALID_MESSAGE);
        this.onAuthError(error);
        this.cleanup();
        // Clean up message listener
        if (popupMessageHandler) {
            window.removeEventListener("message", popupMessageHandler);
        }
    }
    /**
     * Handles the scenario when the authentication popup is closed by the user.
     * This method is called when the popup window is detected as closed during monitoring.
     * It emits an error event, creates an appropriate error, and performs cleanup.
     *
     * @param popupMessageHandler - The message event handler to clean up, or null if none exists
     */
    handlePopupClosed(popupMessageHandler) {
        this.logger.warn("üîí Popup was closed by user");
        this.config.events?.emit(AuthEvent.SIGN_IN_ERROR, {
            detail: "Authentication cancelled by user (popup closed)",
        });
        const error = new CivicAuthError("Authentication cancelled by user", CivicAuthErrorCode.USER_CANCELLED);
        this.onAuthError(error);
        this.cleanup();
        // Clean up message listener
        if (popupMessageHandler) {
            window.removeEventListener("message", popupMessageHandler);
        }
    }
    /**
     * Handles authentication timeout scenarios.
     *
     * Called when the popup monitoring reaches its maximum time limit without
     * receiving authentication results. Emits timeout events, creates timeout errors,
     * and performs cleanup operations.
     *
     * @param popupMessageHandler - The message event handler to clean up, or null if none exists
     */
    handlePopupTimeout(popupMessageHandler) {
        this.logger.warn("‚è∞ Popup monitoring timeout reached");
        this.config.events?.emit(AuthEvent.SIGN_IN_ERROR, {
            detail: "Authentication timeout - popup monitoring stopped",
        });
        const error = new CivicAuthError("Authentication timeout", CivicAuthErrorCode.AUTH_PROCESS_TIMEOUT);
        this.onAuthError(error);
        this.cleanup();
        // Clean up message listener
        if (popupMessageHandler) {
            window.removeEventListener("message", popupMessageHandler);
        }
    }
    /**
     * Monitors the popup's location for redirect changes.
     *
     * Attempts to check if the popup has redirected to the callback URL, which
     * indicates the authentication flow has progressed. Handles cross-origin
     * access restrictions gracefully by catching and logging access errors.
     *
     * @param popup - The popup window to monitor for location changes
     */
    checkPopupLocation(popup) {
        try {
            const popupLocation = popup.location.href;
            this.logger.debug("üìç Popup location accessible", {
                location: popupLocation,
                startsWithRedirect: popupLocation.startsWith(this.config.redirectUrl),
            });
            if (popupLocation.startsWith(this.config.redirectUrl)) {
                this.logger.info("üéØ Popup redirected to callback URL", {
                    location: popupLocation,
                });
                // The callback page should send us a postMessage, so we just wait for that
            }
        }
        catch (error) {
            // Expected when popup is on different origin
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.debug("üîí Cannot access popup location (cross-origin)", {
                error: errorMessage,
            });
        }
    }
}
//# sourceMappingURL=PopupHandler.js.map